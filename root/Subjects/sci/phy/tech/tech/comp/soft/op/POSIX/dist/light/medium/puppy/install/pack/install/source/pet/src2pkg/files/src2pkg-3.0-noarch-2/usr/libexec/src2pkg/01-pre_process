# This file is part of the src2pkg program:
# Copyright 2005-2013 Gilbert Ashley <amigo@ibilio.org>
# src2pkg is released under the GNU General Public License Version 2

##### pre_process
##### This is the only function which is really required as it is where all
##### the main variables get set up and crunched into usable form
pre_process() {
if [[ $ALLOW_USER_EXTENSIONS = "YES" ]] ; then
 # check if the user has any pre-execution extensions to this file and run them, if so.
 [[ -f "$HOME"/.src2pkg/extensions/01.pre ]] && . "$HOME"/.src2pkg/extensions/01.pre
fi

# color is on only if COLOR_PROMPT=YES
get_color_options

# you must be root to run src2pkg in REAL, SAFE or UNION mode
if [[ "$(id -u)" != "0" ]] && [ "$INSTALL_TYPE" = "REAL" -o "$INSTALL_TYPE" = "SAFE" -o "$INSTALL_TYPE" = "UNION" ] ; then
 echo $RED"FATAL!!! "$NORMAL"You have chosen to use the REAL/SAFE/UNION installation option for src2pkg."
 echo "Normal users don't have the write priviledges needed for doing this."
 echo "You must be logged in as root or su to root to run src2pkg in this mode."
 echo "Or choose to use one of the other installation methods: -JAIL or -DESTDIR."
 exit 1
fi

# This routine implements vetting of INSTALL_TYPES using
# INSTALL_FAIL=?? and tries to set the next safest method.
case $INSTALL_FAIL in
	*JAIL*DESTDIR*|*DESTDIR*JAIL*)
		if [[ $EUID != 0 ]] ; then
			echo $RED"Failed! "$NORMAL"You must be root to build this package"
			echo "as neither JAIL nor DESTDIR 'INSTALL_TYPE' is supported."
		else
			case $INSTALL_TYPE in
				JAIL|DESTDIR|UNION)
					case $INSTALL_FAIL in
						*UNION*)	INSTALL_TYPE=REAL ; SAFE_METHOD=YES
							echo $CYAN"   Notice - "$NORMAL"Build fails with JAIL, DESTDIR and UNION"
							echo "   Resetting INSTALL_TYPE to SAFE" ;;
						*)	INSTALL_TYPE=UNION
							echo $CYAN"   Notice - "$NORMAL"Build fails with both JAIL and DESTDIR"
							echo "   Resetting INSTALL_TYPE to UNION" ;;
					esac
			esac
		fi
	;;
	JAIL)
		if [[ $EUID != 0 ]] ; then
			INSTALL_TYPE=DESTDIR
			echo $CYAN"   Notice - "$NORMAL"This package build fails with JAIL"
			echo "   Resetting INSTALL_TYPE to DESTDIR"
		else
			case $INSTALL_TYPE in
				JAIL) INSTALL_TYPE=DESTDIR
					echo $CYAN"   Notice - "$NORMAL"Resetting INSTALL_TYPE to DESTDIR"
					echo "   If build still fails, use UNION or SAFE" ;;
			esac
		fi
	;;
	DESTDIR)
		if [[ $EUID != 0 ]] ; then
			INSTALL_TYPE=JAIL
			echo $CYAN"   Notice - "$NORMAL"Resetting INSTALL_TYPE to JAIL"
			echo "   This package build fails with DESTDIR"
		else
			case $INSTALL_TYPE in
				DESTDIR) INSTALL_TYPE=JAIL
					echo $CYAN"   Notice - "$NORMAL"Resetting INSTALL_TYPE to JAIL"
					echo "   If build still fails, use UNION or SAFE" ;;
			esac
		fi
	;;
	*UNION*DESTDIR*| *DESTDIR*UNION*)
		case $INSTALL_TYPE in
			UNION) INSTALL_TYPE=JAIL
			echo $CYAN"   Notice - "$NORMAL"Resetting INSTALL_TYPE to JAIL"
			echo "If build still fails, use DESTDIR or SAFE"
		esac
	;;
	*UNION*)
		INSTALL_TYPE=SAFE
		echo $CYAN"   Notice - "$NORMAL"Resetting INSTALL_TYPE to SAFE"
		echo "If build still fails, use REAL"
	;;
esac

# if the user is not 'root', then chown commands will not work, so warn 
if [[ $EUID != 0 ]] && [[ -n $SCRIPT ]] ; then
	if [[ $(grep chown $SCRIPT) ]] || \
		[[ $(grep 'install\b' $SCRIPT |grep 'root') ]] ; then
		echo $YELLOW"Warning! "$NORMAL"$SCRIPT uses 'chown' or 'install ... root' command."
		echo $CYAN"Notice - "$NORMAL"But you are not user 'root'. These commands will fail when run."
		echo $CYAN"Notice - "$NORMAL"You may have to build this package as root for proper results."
	fi
fi

OWNER="$(id -un)"
GROUP="$(id -gn)"

# These are important defaults that need to be set
! [[ $STD_MASK ]] && STD_MASK="022"
umask $STD_MASK
! [[ $MAKE_LINKS ]] && MAKE_LINKS="YES"
# REALLY_INSTALL=YES is similar to what checkinstall does.
# Among the first goals of src2pkg was to *not* install packages by default
! [[ $REALLY_INSTALL = "YES" ]] && REALLY_INSTALL="NO"
# This is the most-used option of all. But if not specified it should be nulled.
! [[ $EXTRA_CONFIGS ]] && EXTRA_CONFIGS=""
# A BUILD number is required, so supply a default if none was given.
! [[ $BUILD ]] && BUILD="1"

# get the ARCH and compiler tuning flags  for CFLAGS (function is near end of file)
get_flags ;

# Try to use our own version of binaries installed with the src2pkg-helpers package
# The tar-1.13 program is used in all cases for consistency and to allow
# re-building the 'tar' package. A couple of people have tried upgrading the tar version,
#  but this should *not* be done. There are a couple of very specific reasons for using
# the old version 1.13. Put simply, Slackware packages use a certain format which
# can only be created with tar-1.13. Using later versions of tar breaks compatibility
# with the Slackware pkgtools.
if [[ -x $SRC2PKG_BINDIR/tar-1.13 ]] ; then
 TAR=$SRC2PKG_BINDIR/tar-1.13
elif [[ -x $(which tar-1.13) ]] ; then
 # use the Slackware copy if available and ours is not.
 TAR=$(which tar-1.13)
else
 # you'll be sorry if you don't have tar-1.13, but we'll let you try
 TAR=$(which tar)
 # only warn on Slackware or KISS systems -rpm or deb systems do not require tar-1.13
 if [[ -f /etc/slackware-version ]] || [[ -f /etc/kiss-version ]] ; then
   echo $YELLOW"Warning! "$NORMAL"No tar-1.13 was found in the PATH."
   echo "src2pkg cannot build Slackware or KISS-compatible packages without it."
 fi
fi

# check to make sure we have been setup. If not run setup if the user is root
# otherwise warn the user
if [ -f /usr/libexec/src2pkg/bin/version ] ; then
	INSTALLED_HELPERS_VERSION=`cat /usr/libexec/src2pkg/bin/version`
elif [[ -f $SRC2PKG_LIBDIR/.helpers-version ]] ; then
	INSTALLED_HELPERS_VERSION=$(cat $SRC2PKG_LIBDIR/.helpers-version)
elif [ -f /var/lib/pkgtool/packages/src2pkg-helpers* ] ; then
	INSTALLED_HELPERS_VERSION=$(ls /var/lib/pkgtool/packages/src2pkg-helpers* |cut -f3 -d'-')
elif [ -f /var/log/packages/src2pkg-helpers* ] ; then
	INSTALLED_HELPERS_VERSION=$(ls /var/log/packages/src2pkg-helpers* |cut -f3 -d'-')
else
	INSTALLED_HELPERS_VERSION=0
fi

CURRENT_HELPERS_VERSION="$(grep '^VERSION=' /usr/src/src2pkg/src2pkg-helpers/src2pkg-helpers.src2pkg |cut -f 2 -d'=')"

if [[ ! -x $SRC2PKG_LIBDIR/lib/libsentry.so ]] || [[ "$INSTALLED_HELPERS_VERSION" != "$CURRENT_HELPERS_VERSION" ]] ; then
	if [[ "$(id -u)" = "0" ]] ; then
	  if [[ "$INSTALLED_HELPERS_VERSION" = "0" ]] ; then
		/bin/bash -c "/usr/src/src2pkg/src2pkg-helpers/src2pkg.setup"
	  else
		export UPDATE=1 ; /bin/bash -c "/usr/src/src2pkg/src2pkg-helpers/src2pkg.setup"
	  fi
	  cd $CWD;
	else
	  echo $RED"NOTICE! "$NORMAL"src2pkg has not been setup yet or needs updating."
	  echo "   In order to use src2pkg you must first login as root and run "
	  echo "   src2pkg with the command: 'src2pkg --setup'"
	  exit 0
	fi
fi

# Let's support a 'group' conf file
# a limited number of things could be set here, like SOURCES_DIR, PKG_GROUP
if [[ -f $CWD/Group.conf ]] ; then
	echo $CYAN"   Notice - "$NORMAL"Reading Group.conf in CWD."
	source $CWD/Group.conf
	HAVE_GROUP=1
elif [[ -f $CWD/../Group.conf ]] ; then
	# this lame because there might be cases we don't want this  - NO_GROUP option??
	echo $CYAN"   Notice - "$NORMAL"Reading Group.conf one level up from CWD."
	source $CWD/../Group.conf
	HAVE_GROUP=1
fi
# export PKG_GROUP so it is available to tpkg-make if called from the running script
if [[ -n $PKG_GROUP ]] ; then
	export PKG_GROUP 
fi
# if building multiple packages from the same directory,  setting COMMON_DIR to '1'
# will avoid packing and unpacking the same Resources.tar.bz2 archive for each build
if [[ $COMMON_DIR = 1 ]] ; then
	export COMMON_DIR
fi
# end Group.conf stuff

# Get the name, version and source suffix(SOURCE_NAME)
# early PkgBuild versions supplied NAME VERSION and SRC_SUFFIX separately
if [ "$NAME" -a "$VERSION" -a "$SRC_SUFFIX" ] ; then
 SOURCE_NAME="$NAME-$VERSION$SRC_SUFFIX"
fi
# newer versions of src2pkg derive NAME & VERSION  from SOURCE_URL, SOURCE or SOURCE_NAME
if [[ "$SOURCE_URL" != "" ]] ; then
 # SOURCE_URL was given explicitly
 SOURCE_NAME=$(basename "$SOURCE_URL")
 SOURCE="$SOURCES_DIR/$SOURCE_NAME"
elif [[ "$SOURCE" != "" ]] ; then
	SOURCE_NAME=$(basename "$SOURCE")
	case "$SOURCE" in
		# SOURCE_URL is a torrent file
		*.torrent) SOURCE_URL="$SOURCE" ; SOURCE_NAME="${SOURCE_NAME%.torrent*}" ; SOURCE="$SOURCES_DIR"/"${SOURCE_NAME}" ; shift ;;
		# Normal URL's using http or ftp protocol
		*://*)	SOURCE_URL="$SOURCE" ; SOURCE="$SOURCES_DIR"/"$SOURCE_NAME" ; shift ;;
		# Double slashes get corrected if this is not a URL
		//*)	SOURCE="${SOURCE#*/}" ; shift ;;
		# Relative path(./)
		./*)	SOURCE="$CWD"/"${SOURCE#*/}" ; shift ;;
		# Absoulte path"
		/*)	SOURCE="$SOURCE" ;;
		# Extended relative path
		[a-z,A-Z,0-9]*/*)	SOURCE="$CWD"/"$SOURCE" ; shift ;;
		# No path given -assume it's in SOURCES_DIR
		*)	SOURCE="$SOURCES_DIR"/"$SOURCE" ; shift ;;
	esac
elif [[ "$SOURCE_NAME" != "" ]] ; then
	case "$SOURCE_NAME" in
		# use the same rules as above for SOURCE_NAME
		*://*)	SOURCE_URL="$SOURCE" ; SOURCE="$SOURCES_DIR"/"$SOURCE_NAME" SOURCE_NAME=$(basename "$SOURCE_NAME") ; shift ;;
		//*)	SOURCE="${SOURCE_NAME#*/}" ;;
		./*)	SOURCE="$CWD"/"${SOURCE_NAME#*/}" ;;
		/*)	SOURCE="$SOURCE_NAME" ;;
		[a-z,A-Z,0-9]*/*)	SOURCE="$CWD"/"$SOURCE_NAME" ;;
		*)	SOURCE="$SOURCES_DIR"/"$SOURCE_NAME" ;;
	esac
fi

# local function used to retrieve the given architecture when converting binary package names
get_my_arch() {
ARCH_CHUNK=$(echo $NAMVERS |rev |cut -f1,2 -d'-' |rev)
	case $ARCH_CHUNK in
		*i386*) MYARCH=i386 ;; *i486*) MYARCH=i486 ;; *i586*) MYARCH=i586 ;;
		*i686*) MYARCH=i686 ;; *ppc*) MYARCH=ppc ;; *powerpc*) MYARCH=powerpc ;;
		*x86_64*) MYARCH=x86_64 ;; *s390*) MYARCH=s390 ;; *s390x*) MYARCH=s390x ;; *noarch*) MYARCH=noarch ;;
	esac
}
# local function
translate_underlines() {
if [[ $(echo $NAMVERS |grep -v "_") = "" ]] ; then
	if [[ $(echo $NAMVERS |grep -v ".") = "" ]] ; then
	 #echo "Translating underlines to periods"
	 NAMVERS=$(echo $NAMVERS |tr '_' '.')
	fi
fi
}

tr_underlines_2_periods() {
NAMVERS="${NAMVERS//_/.}"
}


# The next +-200 lines analyze the SOURCE_NAME and try to figure out the correct NAME and VERSION
# Handling of debian and especially rpm archives make this pretty complex. Of course it still won't always
# get them both right. you can always override them easily with '-n=?' (ALT_NAME) and '-v=?' (ALT_VERSION).
# The logic is based on heuristic rules built up from thousands of real archive names and error scenarios
# 
if [[ "$SOURCE_NAME" != "" ]] ; then
   # this eliminates the need for ALT_NAME and ALT_VERSION
   #if [[ "$NAME" = "" ]] && [[ "$VERSION" = "" ]] ; then
	[[ $DEBUG ]] && echo -n $BLUE"Guessed content type: "$NORMAL
	NAMVERS=$(basename "$SOURCE_NAME")
	case $NAMVERS in
		*-source.rpm) EXT='-source.rpm' ;; *-source.tgz) EXT='-source.tgz' ;; *-source.tar.gz) EXT='-source.tar.gz' ;;
		*source.rpm) EXT='source.rpm' ;; *source.tgz) EXT='source.tgz' ;; *source.tar.gz) EXT='source.tar.gz' ;;
		*-source.tbz) EXT='-source.tbz' ;; *-source.tar.bz2) EXT='-source.tar.bz2' ;;
		*source.tbz) EXT='source.tbz' ;; *source.tar.bz2) EXT='source.tar.bz2' ;;
		*-src.rpm) EXT='-src.rpm' ;; *-src.tgz) EXT='-src.tgz' ;; *-src.tar.gz) EXT='-src.tar.gz' ;;
		*src.rpm) EXT='src.rpm' ;; *src.tgz) EXT='src.tgz' ;; *src.tar.gz) EXT='src.tar.gz' ;;
		*rpm) EXT='rpm' ;; *deb) EXT='deb' ;;
		*orig.tar.gz) EXT='orig.tar.gz' ;; *orig.tar.bz2) EXT='orig.tar.bz2' ;;
		*tgz) EXT='tgz' ;; *tbz) EXT='tbz' ;; *tar.gz) EXT='tar.gz' ;; *tar.bz2) EXT='tar.bz2' ;;
		*tlz) EXT='tlz' ;; *tar.lzma) EXT='tar.lzma' ;; *txz) EXT='txz' ;; *tar.xz) EXT='tar.xz' ;;
		*tar.lzma2) EXT='tar.lzma2' ;; *.tar) EXT='tar' ;;
		*zip) EXT='zip' ;;
	esac
	# this is where the user gave just a suffix and no package name
	if [[ $NAMVERS = ".$EXT" ]] || [[ $NAMVERS = $EXT ]] ; then
		echo $RED"Error! "$NORMAL"Invalid package name -probably null name or suffix-only. Exiting..."
		exec src2pkg --help
		exit 0
	else
		if [[ ${EXT:0:1} = '-' ]] ; then
			RAW_SOURCE_NAME=$(basename $NAMVERS "$EXT")
			EXT=${EXT:1}
		else
			RAW_SOURCE_NAME=$(basename $NAMVERS ."$EXT")
		fi
	fi
	NAMVERS=$RAW_SOURCE_NAME
        #if [[ "$NAME" = "" ]] && [[ "$VERSION" = "" ]] ; then
	case $EXT in
		rpm)
			# this is probably a binary rpm package
			# translate_underlines
			get_my_arch
			if [[ $(echo $NAMVERS |grep "$MYARCH") != "" ]] ; then
			  [[ $DEBUG ]] && echo -n "RPM binary package"
			 ARCH=$(echo $NAMVERS |rev |cut -f1 -d'.' |rev)
			 NAMVERS=$(basename $NAMVERS .$ARCH)
			 if [[ $(echo $ARCH |grep "-") ]] ; then
			  ARCH=$(echo $ARCH |rev |cut -f2- -d'-' |rev)
			 fi
			else
			  [[ $DEBUG ]] && echo -n "Generic RPM archive"
			fi
			if [[ $(echo $NAMVERS |rev |cut -f2 -d'-') !=  $(echo $NAMVERS |rev |cut -f3 -d'-') ]] ; then
			 if [[ $(echo $NAMVERS |rev |cut -f1 -d'.' |grep "-") ]] ; then
			  [[ $DEBUG ]] && echo " Rule 1"
			  CHUNK=$(echo $NAMVERS |rev |cut -f1 -d'.' |rev)
			  REV_CHUNK=$(echo $CHUNK |cut -f2- -d'-')
			  CARRY=$(echo $CHUNK |cut -f1 -d'-')
			  NAMVERS=$(basename $NAMVERS .$CHUNK).$CARRY
			 else
			  [[ $DEBUG ]] && echo " Rule 2"
			  REV_CHUNK=$(echo $NAMVERS |rev |cut -f1 -d'-' |rev)
			  NAMVERS=$(echo $NAMVERS |rev |cut -f2- -d'-' |rev)
			 fi
			fi
			if [[ $(echo $NAMVERS |rev |cut -f1 -d'-' |rev |grep "_") ]] ; then
			 [[ $DEBUG ]] && echo " Rule 3"
			 VERSION=$(echo $NAMVERS |rev |cut -f1 -d'-' |rev)
			 VERSION=$(echo $NAMVERS |tr '_' '.')
			 NAME=$(echo $NAMVERS |rev |cut -f2- -d'-' |rev)
			else
			 [[ $DEBUG ]] && echo " Rule 4"
			 VERSION=$(echo $NAMVERS |rev |cut -f1 -d'-' |rev)
			 NAME=$(echo $NAMVERS |rev |cut -f2- -d'-' |rev)
			fi
			;;
		deb)
			 [[ $DEBUG ]] && echo "Debian binary package"
			ARCH=$(echo $NAMVERS |rev |cut -f1 -d'_' |rev)
			NAMVERS=$(echo $NAMVERS |rev |cut -f2- -d'_' |rev)
			if [[ $(echo $NAMVERS |rev |cut -f1 -d'.' |grep '-') ]] ; then
			 NAMVERS=$(echo $NAMVERS |rev |cut -f2- -d'-' |rev)
			fi
			VERSION=$(echo $NAMVERS |cut -f2- -d'_')
			NAME=$(echo $NAMVERS |cut -f1 -d'_')
			;;
		*)
		get_my_arch
		if [[ "$MYARCH" != "" ]] ; then
			if [[ $(echo $ARCH_CHUNK |cut -f1 -d '-') = $ARCH ]] ; then
			   [[ $DEBUG ]] && echo "Slackware binary package"
			  ARCH=$(echo $NAMVERS |rev |cut -f2 -d'-' |rev)
			  NAMVERS=$(echo $NAMVERS |rev |cut -f2- -d'-' |rev)
			  VERSION=$(echo $NAMVERS |rev |cut -f2 -d'-' |rev)
			  NAME=$(basename $NAMVERS -$VERSION-$ARCH)
			elif [[ $(echo $NAMVERS |rev |cut -f1 -d'.' |rev |grep $MYARCH) != "" ]] ; then
				translate_underlines
				ARCH_CHUNK=$(echo $NAMVERS |rev |cut -f1 -d'.' |rev)
				[[ $DEBUG ]] && echo "Binary rpm2$EXT archive"
				NAMVERS=$(basename $NAMVERS .$ARCH_CHUNK)
				#if [[ $(echo $ARCH_CHUNK |grep '-') ]] ; then
				#  ARCH=$(echo $ARCH_CHUNK |rev |cut -f2- -d'-' |rev)
				#else
				#  ARCH="$ARCH_CHUNK"
				#fi
				ARCH="$MYARCH"
				if [[ $(echo $NAMVERS |rev |cut -f1 -d'.' |grep "-") ]] ; then
				  CHUNK=$(echo $NAMVERS |rev |cut -f1 -d'.' |rev)
				  REV_CHUNK=$(echo $CHUNK |cut -f2- -d'-')
				  CARRY=$(echo $CHUNK |cut -f1 -d'-')
				  NAMVERS=$(basename $NAMVERS .$CHUNK).$CARRY
				else
				  REV_CHUNK=$(echo $NAMVERS |rev |cut -f1 -d'-' |rev)
				  NAMVERS=$(echo $NAMVERS |rev |cut -f2- -d'-' |rev)
				fi
				VERSION=$(echo $NAMVERS |rev |cut -f1 -d'-' |rev)
				NAME=$(echo $NAMVERS |rev |cut -f2- -d'-' |rev)
			else
			  translate_underlines
			   [[ $DEBUG ]] && echo "Generic binary $EXT archive"
				if [[ $(echo $NAMVERS |grep '-') ]] ; then
				  VERSION=$(echo $NAMVERS |rev |cut -f1 -d'-' |rev)
				  NAME=$(basename $NAMVERS -$VERSION)
				elif [[ $(echo $NAMVERS |grep '.') ]] ; then
				  NAME=$(echo $NAMVERS |cut -f1 -d'.')
				  NAME=$(echo $NAMVERS |cut -f2- -d'.')
				else
				  echo "What is this?"
				  NAME=unknown
				  VERSION=0.0
				fi
			fi
		else
			case $EXT in
			source.rpm|src.rpm|source.tgz|src.tgz|source.tar.gz|src.tar.gz|tgz|tar.gz|tbz|tar.bz2|orig.tar.gz|orig.tar.bz2|tlz|txz|tar.lzma|tar.xz|tar|zip)
				# this filter should also work for rpm names
				case $SOURCE_NAME in
					*-svn-*) [[ $DEBUG ]] && echo -n "SVN source snapshot"
						NAMVERS=${NAMVERS//-svn-/-} ;;
					*-svn*) [[ $DEBUG ]] && echo -n "SVN source snapshot"
						NAMVERS=${NAMVERS//-svn/-} ;;
					*-cvs-*) [[ $DEBUG ]] && echo -n "CVS source snapshot"
						NAMVERS=${NAMVERS//-cvs-/-} ;;
					*-cvs*) [[ $DEBUG ]] && echo -n "CVS source snapshot"
						NAMVERS=${NAMVERS//-cvs/-} ;;
					*.orig*) [[ $DEBUG ]] && echo -n "Debian source archive" ;;
					*.source.rpm|src.rpm) [[ $DEBUG ]] && echo -n "RPM source archive" ;;
					*.source.tgz|src.tgz) [[ $DEBUG ]] && echo -n "Converted(maybe) RPM source archive" ;;
					*) [[ $DEBUG ]] && echo -n "Generic source archive" ;;
				esac
				
				# if there are dashes to the right of periods
				# keep left side of last dash -two times for good measure
				case $NAMVERS in *.*-*) NAMVERS=${NAMVERS%-*} ;; esac
				case $NAMVERS in *.*-*) NAMVERS=${NAMVERS%-*} ;; esac
				
				# what should we do with tildes? Blank them or convert to '-', '.'  or '_'
				# converting them to '-' would makesthem get cut off below
				# either way, check to make sure we don't get doubled '.' or '_' chars
				case $NAMVERS in 
					*.*~*) NAMVERS=${NAMVERS/\~/.} ; NAMVERS=${NAMVERS//../.} ;; 
					*~*) NAMVERS=${NAMVERS/\~/_} ; NAMVERS=${NAMVERS//__/_} ;; 
				esac
				case $NAMVERS in
					# Hocus-pocus -Don't ask how I came up with this order,
					# but running them through backwards also works...
					# cases 1, 6 ,7 and 8 do the same   and cases 2, 3, 4, 5 do the same
					# ALPHA_APLHA-DIGIT.DIGIT
					# xdotool_new-2009.01.26		1
					*_*-*.*) [[ $DEBUG ]] && echo " case 1" 
						NAME=${NAMVERS%-*} ; VERSION=${NAMVERS##*-} ;;
					# ALPHA-ALPHA_DIGIT.DIGIT 
					# xdotool-new_2009.01.26		2
					*-*_*.*) [[ $DEBUG ]] && echo " case 2" 
						NAME=${NAMVERS%_*} ; VERSION=${NAMVERS##*_} ;;
					# ALPHA-DIGIT_DIGIT 
					# somename-1_23
					*-[0-9]_[0-9].*) [[ $DEBUG ]] && echo " case 2A" 
						NAME=${NAMVERS%-*} ; VERSION=${NAMVERS##*-} ;;
					# ALPHA_DIGIT.DIGIT
					# xdotool_new_2009.01.26		3
					*_*_*.*) [[ $DEBUG ]] && echo " case 3" 
						NAME=${NAMVERS%_*} ; VERSION=${NAMVERS##*_} ;;
					# ALPHA_DIGIT.DIGIT
					# xdotool_2009.01.26		4
					*_*.*) [[ $DEBUG ]] && echo " case 4" 
						NAME=${NAMVERS%_*} ; VERSION=${NAMVERS##*_} ;;
					# ALPHA_DIGIT  or ALPHA_ALPHA
					# xdotool_20090126			5
					*_*) [[ $DEBUG ]] && echo " case 5" 
						NAME=${NAMVERS%_*} ; VERSION=${NAMVERS##*_} ;;
					# ALPHA-DIGIT.DIGIT 
					# xdotool-2009.01.26		6
					*-*-*.*) [[ $DEBUG ]] && echo " case 6" 
						NAME=${NAMVERS%-*} ; VERSION=${NAMVERS##*-} ;;
					# ALPHA-DIGIT.DIGIT 
					# xdotool-2009.01.26		7
					*-*.*) [[ $DEBUG ]] && echo " case 7" 
						NAME=${NAMVERS%-*} ; VERSION=${NAMVERS##*-} ;;
					# ALPHA-DIGIT  or ALPHA_ALPHA
					# xdotool-20090126			8
					*-*) [[ $DEBUG ]] && echo " case 8" 
						NAME=${NAMVERS%-*} ; VERSION=${NAMVERS##*-} ;;
					# ALPHADIGITS or ALPHA (no separators)
					# xdotool20090126			9
					*) [[ $DEBUG ]] && echo -n " case 9" 
						case $NAMVERS in
							[a-z]*[0-9]) [[ $DEBUG ]] && echo "A" 
								NAME=${NAMVERS%%[0-9]*}
								VERSION=${NAMVERS##*[a-z]}
							;;
							*) [[ $DEBUG ]] && echo "B" ; NAME=$NAMVERS ; VERSION=0.0.0
							;;
						esac
					;;
				esac
			esac
		fi
	;;
	esac
	#[[ $DEBUG ]] && echo ""
	# Whew!! The derived name and version can always be overridden.
        #else
         # NAME & VERSION were already set
        # echo $BLUE"Using NAME:"$NORMAL" $NAME"
        # echo $BLUE"Using VERSION:"$NORMAL" $VERSION"
        #fi
else
	# trackinstall and src2pkg are 'clients' of these FUNCTIONS
	if [[ $NAME ]] && [[ $VERSION ]] ; then
	 NAMVERS="$NAME-$VERSION"
	 echo $BLUE"Client or user supplied NAME and VERSION: "$NORMAL"$NAMVERS"
	else
	 NAMVERS=$(basename "$CWD")
	 echo $BLUE"Using NAME and VERSION from CWD: "$NORMAL"$NAMVERS"
	fi
	if [[ $(echo $NAMVERS |grep '-') != "" ]] ; then
	 VERSION=$(echo $NAMVERS |rev |cut -f1 -d'-' |rev)
	 NAME=$(basename $NAMVERS -$VERSION)
	elif [[ $(echo $NAMVERS |grep '_') != "" ]] ; then
	 VERSION=$(echo $NAMVERS |rev |cut -f1 -d'_' |rev)
	 NAME=$(basename $NAMVERS _$VERSION)
	elif [[ $(echo $NAMVERS |grep '.') ]] ; then
	 NAME=$(echo $NAMVERS |cut -f1 -d'.')
	 VERSION=$(echo $NAMVERS |cut -f2- -d'.')
	 [[ "$VERSION" = "$NAME" ]] && VERSION=0.0.0
	else
	 echo "What in the world is this? We'll name it: unknown-0.unknown.0 "
	 NAME=unknown
	 VERSION=0.unknown.0
	fi
	VERSION=$(echo $VERSION |tr '-' '_')
fi

# ORIG_NAME & ORIG_VERSION are the 'best guess' from above. We save the values before
# correcting or overriding them. They are used later to help second-guess tarball names, if needed.
ORIG_NAME="$NAME"
ORIG_VERSION="$VERSION"

[[ $DEBUG ]] && echo $BLUE"ORIG_NAME="$NORMAL"$ORIG_NAME"
[[ $DEBUG ]] && echo $BLUE"ORIG_VERSION="$NORMAL"$ORIG_VERSION"

# Now correct the name for capital letters if needed and corrections are not turned off or overridden
if [[ $(echo $NAME | grep -e "[A-Z]") ]] ; then
	if [[ $ALT_NAME = "" ]] ; then
		echo $BLUE"Notice - "$NORMAL"Source name contains capital letters."
	fi
	if [[ "$CORRECT_NAMES" = "YES" ]] && [[ ! $ALT_NAME ]] ; then
		ALT_NAME=$(echo $NAME | tr 'A-Z' 'a-z')
	elif [[ $ALT_NAME ]] ; then
		if echo $ALT_NAME | grep -e "[A-Z]" &> /dev/null ; then
			echo $BLUE"Notice - "$NORMAL"Alternate Name contains capital letters."
			echo -n "A better name for $ALT_NAME  might be:  "
			echo $ALT_NAME | tr 'A-Z' 'a-z'
		fi
	fi
fi

if [[ $SET_COMPAT_NAME = 1 ]] ; then
	if [[ -z $ALT_NAME ]] ; then
		ALT_NAME="${COMPAT_NAME_PREFIX}${NAME}${COMPAT_NAME_SUFFIX}"
	elif [[ "$(echo $ALT_NAME |grep $COMPAT_NAME_SUFFIX)" = "" ]] ; then
		ALT_NAME="${COMPAT_NAME_PREFIX}${ALT_NAME}${COMPAT_NAME_SUFFIX}"
	elif [[ "$(echo $ALT_NAME |grep $COMPAT_NAME_PREFIX)" = "" ]] ; then
		ALT_NAME="${COMPAT_NAME_PREFIX}${ALT_NAME}${COMPAT_NAME_SUFFIX}"
	fi
fi

if [[ "$ALT_VERSION" != "" ]] ; then
  if echo $ALT_VERSION | grep -e "-" &> /dev/null ; then
   echo $YELLOW"ERROR - "$NORMAL"Version numbers with a '-' character are not allowed." 
   ALT_VERSION=$(echo $ALT_VERSION |tr '-' '.')
  fi
  echo $BLUE"Resetting version number - "$NORMAL"Using: "$BLUE"$ALT_VERSION"$NORMAL
  VERSION="$ALT_VERSION"
fi

if [[ "$ALT_NAME" != "" ]] ; then
 echo $BLUE"Resetting package name - "$NORMAL"Using: "$BLUE"$ALT_NAME"$NORMAL
 NAME="$ALT_NAME"
fi
# exit if no NAME or VERSION are found
if [[ ! $NAME ]] ; then
 echo $RED"ERROR - "$NORMAL"Unable to find a NAME. Please give one!" 
 exit
elif [[ ! $VERSION ]] ; then
 echo $RED"ERROR - "$NORMAL"Unable to find a VERSION. Please give one!" 
 exit
fi

if [[ $TRACK_INSTALL ]] ; then
 SRC_DIR="$CWD"
 OBJ_DIR="$SRC_DIR"
elif [[ $USE_OBJ_DIR ]] ; then
 SRC_DIR_NAME=$NAME-$VERSION-src-$BUILD$SIG
 SRC_DIR="$SRC_BUILDS_DIR"/$SRC_DIR_NAME
 OBJ_DIR_NAME=$NAME-$VERSION-obj-$BUILD$SIG
 OBJ_DIR="$SRC_BUILDS_DIR"/$OBJ_DIR_NAME
elif [[ $SOURCE_NAME ]] ; then
 # let configure_source sort our CONFIG_DIR and OBJ_DIR
 SRC_DIR_NAME=$NAME-$VERSION-src-$BUILD$SIG
 SRC_DIR="$SRC_BUILDS_DIR"/$SRC_DIR_NAME
elif [[ $NAME ]] && [[ $VERSION ]] ; then
 # try assuming this, which should allow using a src2pkg script inside sources
 SRC_DIR="$CWD"
 OBJ_DIR="$SRC_DIR"
fi

PKG_DIR_NAME=$NAME-$VERSION-$ARCH-$BUILD$SIG
PKG_DIR="$PKG_BUILDS_DIR"/$PKG_DIR_NAME

# these are internal abbreviations to shorten code lines
SHORT_NAME="${NAME}-${VERSION}-${ARCH}-${BUILD}${SIG}"
DEVEL_PKG_NAME="${NAME}-devel-${VERSION}-${ARCH}-${BUILD}${SIG}"
I18N_PKG_NAME="${NAME}-nls-${VERSION}-noarch-${BUILD}${SIG}"
DOCS_PKG_NAME="${NAME}-docs-${VERSION}-noarch-${BUILD}${SIG}"
SOLIBS_PKG_NAME="${NAME}-solibs-${VERSION}-${ARCH}-${BUILD}${SIG}"
# set up some distro-specific policies
if [[ "$PKG_FORMAT" = "tpkg" ]] || [[ "$PKG_FORMAT" = "tpm" ]] ; then
	# tpkg package name format
	PKG_NAME="${NAME}_${VERSION}-${ARCH}-${BUILD}${SIG}"
	PKG_DIR_NAME=${PKG_NAME}
	PKG_DIR="$PKG_BUILDS_DIR/${PKG_DIR_NAME}"
	SHORT_NAME="${NAME}_${VERSION}-${ARCH}-${BUILD}${SIG}"
	! [[ $DEVEL_TAG ]] && DEVEL_TAG=devel
	! [[ $DOCS_TAG ]] && DOCS_TAG=docs
	! [[ $I18N_TAG ]] && I18N_TAG=nls
	! [[ $SOLIBS_TAG ]] && SOLIBS_TAG=solibs

	DEVEL_PKG_NAME="${NAME}-${DEVEL_TAG}_${VERSION}-${ARCH}-${BUILD}${SIG}"
	I18N_PKG_NAME="${NAME}-${I18N_TAG}_${VERSION}-noarch-${BUILD}${SIG}"
	DOCS_PKG_NAME="${NAME}-${DOCS_TAG}_${VERSION}-noarch-${BUILD}${SIG}"
	SOLIBS_PKG_NAME="${NAME}-${SOLIBS_TAG}_${VERSION}-${ARCH}-${BUILD}${SIG}"
	# ADD_PROVIDES_FILE="NO"
elif [[ "$PKG_FORMAT" = "deb" ]] ; then
	case "$ARCH" in
		noarch) ARCH=all ;;
		i?86) ARCH=i386 ;;
		x86_64) ARCH=amd64 ;;
	esac
	! [[ $FHS_POLICY ]] && FHS_POLICY=LSB
	# debian package names have a different format
	PKG_NAME="${NAME}_${VERSION}-${BUILD}${SIG}_$ARCH"
	PKG_DIR_NAME=${PKG_NAME}
	PKG_DIR="$PKG_BUILDS_DIR/${PKG_DIR_NAME}"
	! [[ $DEVEL_TAG ]] && DEVEL_TAG=dev
	! [[ $DOCS_TAG ]] && DOCS_TAG=docs
	! [[ $I18N_TAG ]] && I18N_TAG=nls
	! [[ $SOLIBS_TAG ]] && SOLIBS_TAG=solibs
	DEVEL_PKG_NAME="${NAME}-${DEVEL_TAG}_${VERSION}-${BUILD}${SIG}_${ARCH}"
	I18N_PKG_NAME="${NAME}-${I18N_TAG}_${VERSION}-${BUILD}${SIG}_all"
	DOCS_PKG_NAME="${NAME}-${DOCS_TAG}_${VERSION}-${BUILD}${SIG}_all"
	SOLIBS_PKG_NAME="${NAME}-${SOLIBS_TAG}_${VERSION}-${BUILD}${SIG}_${ARCH}"
elif [[ "$PKG_FORMAT" = "rpm" ]] ; then
	! [[ $FHS_POLICY ]] && FHS_POLICY=LSB
	PKG_NAME="${NAME}-$VERSION-${BUILD}${SIG}.$ARCH"
	PKG_DIR_NAME=${PKG_NAME}
	PKG_DIR="$PKG_BUILDS_DIR/${PKG_DIR_NAME}"
	! [[ $DEVEL_TAG ]] && DEVEL_TAG=dev
	! [[ $DOCS_TAG ]] && DOCS_TAG=docs
	! [[ $I18N_TAG ]] && I18N_TAG=nls
	! [[ $SOLIBS_TAG ]] && SOLIBS_TAG=solibs
	DEVEL_PKG_NAME="${NAME}-${DEVEL_TAG}-${VERSION}-${BUILD}${SIG}.${ARCH}"
	I18N_PKG_NAME="${NAME}-${I18N_TAG}-${VERSION}-${BUILD}${SIG}.noarch"
	DOCS_PKG_NAME="${NAME}-${DOCS_TAG}-${VERSION}-${BUILD}${SIG}.noarch"
	SOLIBS_PKG_NAME="${NAME}-$SOLIBS_TAG-${VERSION}-${BUILD}${SIG}.${ARCH}"
elif [[ "$PKG_FORMAT" = "tazpkg" ]] ; then
	! [[ $FHS_POLICY ]] && FHS_POLICY=LSB
	! [[ $libexecdir ]] && libexecdir=/usr/lib${LIBDIRSUFFIX}/$NAME
elif [[ "$PKG_FORMAT" = "pet" ]] ; then
	PKG_NAME="${NAME}-$VERSION-$ARCH-${BUILD}${SIG}"
	! [[ $FHS_POLICY ]] && FHS_POLICY=NONE
	! [[ $DEVEL_TAG ]] && DEVEL_TAG=DEV
	! [[ $DOCS_TAG ]] && DOCS_TAG=DOC
	! [[ $I18N_TAG ]] && I18N_TAG=NLS
	! [[ $SOLIBS_TAG ]] && SOLIBS_TAG=SOLIBS

	DEVEL_PKG_NAME="${NAME}_${DEVEL_TAG}-${VERSION}-${ARCH}-${BUILD}${SIG}"
	I18N_PKG_NAME="${NAME}_${I18N_TAG}-${VERSION}-noarch-${BUILD}${SIG}"
	DOCS_PKG_NAME="${NAME}_${DOCS_TAG}-${VERSION}-noarch-${BUILD}${SIG}"
	SOLIBS_PKG_NAME="${NAME}_${SOLIBS_TAG}-${VERSION}-${ARCH}-${BUILD}${SIG}"
	ADD_REQUIRED_FILE="NO"
	ADD_SUGGESTS_FILE="NO"
	ADD_PROVIDES_FILE="NO"
	EXTENDED_DATABASE=NO
else
	PKG_NAME=$SHORT_NAME
	! [[ $FHS_POLICY ]] && FHS_POLICY=SLACK
	! [[ $libexecdir ]] && libexecdir=/usr/sbin
fi
PACKAGE="$PKG_DEST_DIR"/$PKG_NAME.$PKG_FORMAT
DEVEL_PACKAGE="$PKG_DEST_DIR"/$DEVEL_PKG_NAME.$PKG_FORMAT
I18N_PACKAGE="$PKG_DEST_DIR"/$I18N_PKG_NAME.$PKG_FORMAT
DOCS_PACKAGE="$PKG_DEST_DIR"/$DOCS_PKG_NAME.$PKG_FORMAT
SOLIBS_PACKAGE="$PKG_DEST_DIR"/$SOLIBS_PKG_NAME.$PKG_FORMAT

# This should help make code from SlackBuild scripts compatible
PKG="$PKG_DIR"
PKGNAM="$NAME"
PRGNAM="$NAME"

# rearrange the SPLIT_PACKAGE options so that operations
# are done in the right order. devel should be done first because
# it will split out man2/man3 pages. i18n should be done before
# docs so that intl manpages are stripped out first
if [[ $SPLIT_PACKAGE != "" ]] ; then
	OLD_IFS=$IFS
	IFS=',' ; for OPT in $SPLIT_PACKAGE ; do
		case $OPT in
			*devel*|*dev*) devel=1 ;;
			*docs*|*doc*) docs=1 ;;
			*nls*|*i18n*) nls=1 ;;
			*solibs*|*libs*) solibs=1 ;;
		esac
	done
	IFS=$OLD_IFS
	for OPT in devel nls docs solibs ; do
		if [[ ${!OPT} ]] ; then
			NEW_SPLIT_PACKAGE=$NEW_SPLIT_PACKAGE,$OPT
		fi
	done
	#strip the leading comma
	SPLIT_PACKAGE=${NEW_SPLIT_PACKAGE:1}
fi

# ! [[ $LOG_DIR ]] && LOG_DIR="$OBJ_DIR"

# remove the leading / from PRE_FIX. This obsoletes some of my own old scripts that used
# $PKG_DIR$PREFIX, but that just doesn't look or feel right like writing:  $PKG_DIR/$PREFIX
# don't remove it if '/' *is* the prefix
if [[ ${#PRE_FIX} -gt 1 ]] && [[ $(echo ${PRE_FIX:0:1}) = "/" ]] ; then
# if [[ $(echo ${PRE_FIX:0:1}) = "/" ]] ; then
	PRE_FIX="$(echo ${PRE_FIX:1})"
fi

# remove any double slashes
PRE_FIX=${PRE_FIX//\/\//\/}

# also remove trailing slashes
#pflen=${#PRE_FIX}
#pfoffset=$(( $pflen - 1 ))
#if [[ ${#PRE_FIX} -gt 1 ]] && [[ $(echo ${PRE_FIX:$pfoffset:1}) = "/" ]] ; then
#	PRE_FIX="$(echo ${PRE_FIX:0:$pfoffset})"
#fi

case $PRE_FIX in
	'/') : ;;
	'/'*'/')	PRE_FIX=${PRE_FIX:1} ; PRE_FIX=${PRE_FIX:0:((${#PRE_FIX}-1))} ;;
	'/'*)	PRE_FIX=${PRE_FIX:1} ;;
	*'/') PRE_FIX=${PRE_FIX:0:((${#PRE_FIX}-1))} ;;
esac

# set default text for the description file if not given
! [[ $BLURB_1 ]] && BLURB_1=$NAME
! [[ $BLURB_3 ]] && BLURB_3="No description was given for this package."

# If the -W (--cleanup) option is used it will remove the generated build files
# new.doinst.sh new.slack.desc and *.src2pkg.auto. But if there is a 
# src2pkg.auto file present here from the start don't remove it.
if [[ -f "$CWD"/$NAME.src2pkg.auto ]] || [[ -f "$CWD"/$NAME.src2pkg ]] ; then
 ! [[ $DONT_CLOBBER_SCRIPT ]] && DONT_CLOBBER_SCRIPT=1
fi

# now check to make sure the user has permission to write in all the needed places
check_write_permissions

if [[ "$FAILED" != "" ]] ; then
	post_process
fi

set_system_dirs

set_search_dirs

# check the validity of the directories (function near end of file). This important check
# insures that the user isn't trying to unpack sources or build packages inside some
# system directory or / root directory.
check_dirs1

if [[ $ALLOW_USER_EXTENSIONS = "YES" ]] ; then
 # check if the user has any post-execution extensions to this file and run them, if so.
 [[ -f "$HOME"/.src2pkg/extensions/01.post ]] && . "$HOME/".src2pkg/extensions/01.post
fi

# Use 'type' to determine whether the script contains a function named 'build'
if [[ "$(type build 2> /dev/null |head -n 1)" = "build is a function" ]] ; then
	CONFIG_COMMAND=skip
	MAKE_COMMAND=skip
	INSTALL_COMMAND=skip
	HAVE_BUILD_FUNCTION=1
fi
# re-read a couple of variables from the src2pkg script. Doing this again allows
# us to use variables near the top of a build script before they are set by pre_process
if [[ -n "$SCRIPT" ]] ; then
	CUTOUT=$(grep -nH '/usr/libexec/src2pkg/FUNCTIONS' "$SCRIPT" |cut -f2 -d:)
	(( CUTOUT--))
	head -n $CUTOUT "$SCRIPT" |egrep -v '^(#|NAME|ALT_NAME|SOURCE_NAME|VERSION)' > "$CWD"/re-read.tmp
	. "$CWD"/re-read.tmp
	rm -f "$CWD"/re-read.tmp
fi
# find out which terminal we can use if needed
if [[ $TERMINAL_EMULATOR = "" ]] ; then
	detect_terminal_emulator
fi
}
# end of very long pre_process

## below are sub-functions called by pre_process
# this function figures out the architecture and CFLAGS
get_flags() {
#
if [[ $(gcc -dumpversion) > 3.4 ]] ; then
	CPU_TAG="-mtune"
else
	CPU_TAG="-mcpu"
fi
# Machine architecture tuning flags and package ARCH
if [[ "$(uname -m)" = "ppc" ]] ; then
	! [[ $ARCH ]] && ARCH="powerpc"
	! [[ $TUNE_FLAGS ]] && TUNE_FLAGS=""
	! [[ $OPTIM_FLAGS ]] && OPTIM_FLAGS="-O0"
elif [[ "$(uname -m)" = "powerpc" ]] ; then
	! [[ $ARCH ]] && ARCH="powerpc"
	! [[ $TUNE_FLAGS ]] && TUNE_FLAGS=""
	! [[ $OPTIM_FLAGS ]] && OPTIM_FLAGS="-O0"
elif [[ "$(uname -m)" = "s390" ]] ; then
	! [[ $ARCH ]] && ARCH="s390"
	! [[ $TUNE_FLAGS ]] && TUNE_FLAGS=""
	! [[ $OPTIM_FLAGS ]] && OPTIM_FLAGS="-O0"
elif [[ "$(uname -m)" = "s390x" ]] ; then
	! [[ $ARCH ]] && ARCH="s390x"
	! [[ $TUNE_FLAGS ]] && TUNE_FLAGS=""
	! [[ $OPTIM_FLAGS ]] && OPTIM_FLAGS="-O0"
#elif [[ "$(uname -i)" = "AuthenticAMD" ]] ; then
	# ! [[ $ARCH ]] && ARCH="athlon_xp"
	# ! [[ $OPTIM_FLAGS ]] && OPTIM_FLAGS="-O3 -pipe -fomit-frame-pointer"
	# ! [[ $TUNE_FLAGS ]] && TUNE_FLAGS="-march=athlon-xp"
elif [[ "$(uname -m)" = "x86_64" ]] ; then
	if [[ $MACHINE = "-m32" ]] ; then
		! [[ $MARCH_FLAG ]] && MARCH_FLAG="i486"
		if ! [[ $ARCH ]] ; then
			case $PKG_FORMAT in
				deb) ARCH="i386" ;;
				*) ARCH="$MARCH_FLAG" ;;
			esac
		fi
		! [[ $CPU_FLAG ]] && CPU_FLAG="i686"
		! [[ $TUNE_FLAGS ]] && TUNE_FLAGS="$(echo -march=$MARCH_FLAG $CPU_TAG=$CPU_FLAG |white_out)"
		if [[ ! $LIBDIRSUFFIX ]] || [[ $LIBDIRSUFFIX = "NULL" ]] ; then
			LIBDIRSUFFIX=""
		fi
		# set this so the NAME gets properly set with a suffix like '-compat32'
		# set COMPAT_NAME_SUFFIX in src2pkg.conf
		SET_COMPAT_NAME=1
	else
		if ! [[ $ARCH ]] ; then
			case $PKG_FORMAT in
				deb) ARCH="amd64" ;;
				*) ARCH="x86_64" ;;
			esac
		fi
		! [[ $MACHINE ]] && MACHINE="-m64"
		if [[ $LIBDIRSUFFIX = "NULL" ]] ; then
			LIBDIRSUFFIX=""
		elif ! [[ $LIBDIRSUFFIX ]] ; then
			LIBDIRSUFFIX="64"
		fi
		! [[ $OPTIM_FLAGS ]] && OPTIM_FLAGS="-O2 -fPIC"
		#! [[ $TUNE_FLAGS ]] && TUNE_FLAGS="-fPIC"
	fi
elif [[ "$(uname -m |grep 86)" != "" ]] ; then
	! [[ $MARCH_FLAG ]] && MARCH_FLAG="i486"
	! [[ $CPU_FLAG ]] && CPU_FLAG="i686"
	# ARCH is for the package name.
	if ! [[ $ARCH ]] ; then
		case $PKG_FORMAT in
			deb) ARCH="i386" ;;
			*) ARCH="$MARCH_FLAG" ;;
		esac
	fi
	! [[ $TUNE_FLAGS ]] && TUNE_FLAGS="$(echo -march=$MARCH_FLAG $CPU_TAG=$CPU_FLAG |white_out)"
	! [[ $MACHINE ]] && MACHINE="-m32"
	if [[ $LIBDIRSUFFIX = "NULL" ]] || ! [[ $LIBDIRSUFFIX ]] ; then
		LIBDIRSUFFIX=""
	fi
elif [[ "$(uname -m )" = "arm" ]] ; then
	! [[ $MARCH_FLAG ]] && MARCH_FLAG="armv4"
	! [[ $CPU_FLAG ]] && CPU_FLAG="xscale"
	! [[ $ARCH ]] && ARCH="$MARCH_FLAG"
	! [[ $TUNE_FLAGS ]] && TUNE_FLAGS="$(echo -march=$MARCH_FLAG $CPU_TAG=$CPU_FLAG |white_out)"
	! [[ $MACHINE ]] && MACHINE="-"
elif [[ "$(uname -m )" = "armel" ]] ; then
	! [[ $MARCH_FLAG ]] && MARCH_FLAG="armv4t"
	! [[ $CPU_FLAG ]] && CPU_FLAG="armv4t"
	! [[ $ARCH ]] && ARCH="$MARCH_FLAG"
	! [[ $TUNE_FLAGS ]] && TUNE_FLAGS="$(echo -march=$MARCH_FLAG $CPU_TAG=$CPU_FLAG |white_out)"
	! [[ $MACHINE ]] && MACHINE="-"
else
	#! [[ $ARCH ]] && ARCH="unknown"
	! [[ $ARCH ]] && ARCH="$(uname -m )"
	! [[ $TUNE_FLAGS ]] && TUNE_FLAGS=""
fi

if [[ $LIBDIRSUFFIX = "NULL" ]] || ! [[ $LIBDIRSUFFIX ]] ; then
	LIBDIRSUFFIX=""
fi
# Compiler options
# Optimize for smaller binaries  
[[ $OPTIMIZE_4_SIZE = "YES" ]] || [[ $OPTIMIZE_FOR_SIZE = "YES" ]] && OPTIM_FLAGS="-Os"
# optimize for maximum speed 
[[ $OPTIMIZE_4_SPEED = "YES" ]] || [[ $OPTIMIZE_FOR_SPEED = "YES" ]] && OPTIM_FLAGS="-O3"

! [[ $OPTIM_FLAGS ]] && OPTIM_FLAGS="-O2"

if [[ ! $LDFLAGS ]] ;then
	LDFLAGS="-Wl,-O1,-L/lib$LIBDIRSUFFIX,-L/usr/lib$LIBDIRSUFFIX"
elif [[ $LDFLAGS != "none" ]] && [[ ! $LDFLAGS =~ '-L/' ]] ; then
	LDFLAGS="-Wl,-O1,$LDFLAGS,-L/lib$LIBDIRSUFFIX,-L/usr/lib$LIBDIRSUFFIX"
fi

! [[ $STD_FLAGS ]] && STD_FLAGS="$(echo $OPTIM_FLAGS $MACHINE $EXTRA_FLAGS $TUNE_FLAGS |white_out)"

# add PKG_CONFIG and PKG_CONFIG_PATH and PKG_CONFIG_LIBDIR
! [[ $PKG_CONFIG ]] && PKG_CONFIG=$(which pkg-config 2> /dev/null)
export PKG_CONFIG
if ! [[ $(echo $PKG_CONFIG_PATH |grep "/usr/lib$LIBDIRSUFFIX/pkgconfig") ]] ; then
	OLD_PKG_CONFIG_PATH=$PKG_CONFIG_PATH
	unset PKG_CONFIG_PATH
	PKG_CONFIG_PATH=/usr/lib$LIBDIRSUFFIX/pkgconfig:$OLD_PKG_CONFIG_PATH
	export PKG_CONFIG_PATH
fi
# PKG_CONFIG_LIBDIR appears to be a debian-specific setting for dpkg-build when cross-compiling
# So, if it is set, use it instead of PKG_CONFIG_PATH
if [[ $PKG_CONFIG_LIBDIR ]] ; then
	unset PKG_CONFIG_PATH
	export PKG_CONFIG_LIBDIR
fi

# find build, host and target
if ! [[ $BUILD_OS ]] ; then
	BUILD_OS=$(gcc -dumpmachine)
fi
if ! [[ $HOST_OS ]] ; then
	HOST_OS=$BUILD_OS
fi
if ! [[ $TARGET_OS ]] ; then
	TARGET_OS=$BUILD_OS
fi
}


check_dirs1 () {
for VAR_NAME in PKG_BUILDS_DIR PKG_DEST_DIR SRC_DIR PKG_DIR CWD; do
	if [[ "${!VAR_NAME}" = "" ]] ; then
	 echo $RED"FATAL! "$NORMAL"Null value given for critical src2pkg variable."
	 echo "Please read the src2pkg documentation for help."
	 exit 1
	fi
	if [[ "${!VAR_NAME}" = "/" ]] ; then
	 echo $RED"FATAL! "$NORMAL"Root directory was given as a critical src2pkg variable,"
	 echo "or is the current directory. Please read the src2pkg documentation for help."
	 exit 1
	fi
	if [[ "${!VAR_NAME}" = "${HOME}" ]] ; then
	 if [[ "${VAR_NAME}" = "PKG_DEST_DIR" ]] ; then
	  true
	 else
	  echo $RED"FATAL! "$NORMAL"Home directory was given as a critical src2pkg variable,"
	  echo "or is the current directory. Please read the src2pkg documentation for help."
	  exit 1
	 fi
	fi
	#
	MISC_DIRS="boot etc dev home mnt opt proc root sys usr var usr/share usr/local"
	CRITICAL_DIRS="$BIN_DIRS $LIB_DIRS $INC_DIRS $LOCALE_DIRS $MAN_DIRS $MISC_DIRS"
	for SYSTEM_DIR in $(echo $CRITICAL_DIRS 2> /dev/null) ; do
		SYSTEM_DIR="/""$SYSTEM_DIR"
		if [[ "${!VAR_NAME}" = "$SYSTEM_DIR" ]] ; then
		 echo $RED"FATAL! "$NORMAL"$SYSTEM_DIR was given as a critical src2pkg variable,"
		 echo "or is the current directory. Please read the src2pkg documentation for help."
		exit 1
		fi
	done
done
}

set_system_dirs() {
# if the user is installing somewhere under/usr/local or /opt, let them do what they want?
# this keeps Makefiles, docs and man-pages from being messed with 
if [[ $(echo $PRE_FIX |grep "usr/local") ]] || [[ $(echo $PRE_FIX |grep "opt/") ]] ; then
CORRECT_MAKEFILES="NO"
CORRECT_DOCS="NO"
CORRECT_MANS="NO"
fi

if [[ $FHS_POLICY = "SLACK" ]] ; then
	! [[ $BIN_DIR ]] && BIN_DIR=usr/bin
	! [[ $SBIN_DIR ]] && SBIN_DIR=usr/sbin
	! [[ $SYSCONF_DIR ]] && SYSCONF_DIR=etc
	! [[ $SHAREDSTATE_DIR ]] && SHAREDSTATE_DIR=var/log
	! [[ $LOCALSTATE_DIR ]] && LOCALSTATE_DIR=var
	! [[ $LIB_DIR ]] && LIB_DIR=usr/lib$LIBDIRSUFFIX
	! [[ $INCLUDE_DIR ]] && INCLUDE_DIR=usr/include
	! [[ $DATA_DIR ]] && DATA_DIR=usr/share
	! [[ $INFO_DIR ]] && INFO_DIR=usr/info
	! [[ $LOCALE_DIR ]] && LOCALE_DIR=$DATA_DIR/locale
	! [[ $MAN_DIR ]] && MAN_DIR=usr/man
	! [[ $DOC_DIR ]] && DOC_DIR=usr/doc
	! [[ $GAMESBIN_DIR ]] && GAMESBIN_DIR=usr/bin
	! [[ $GAMESDATA_DIR ]] && GAMESDATA_DIR=usr/share
	! [[ $INIT_DIR ]] && INIT_DIR=etc/rc.d
	BAD_DOC_PATH=usr/share/doc
	GOOD_DOC_PATH=usr/doc
	BAD_MAN_PATH=usr/share/man
	GOOD_MAN_PATH=usr/man
	BAD_INFO_PATH=usr/share/info
	GOOD_INFO_PATH=usr/info
elif [[ $FHS_POLICY = "LSB" ]] ; then
	! [[ $BIN_DIR ]] && BIN_DIR=usr/bin
	! [[ $SBIN_DIR ]] && SBIN_DIR=usr/sbin
	if [[ $PKG_FORMAT = 'tpkg' ]] ; then
		! [[ $LIBEXEC_DIR ]] && LIBEXEC_DIR=usr/libexec
	else
		! [[ $LIBEXEC_DIR ]] && LIBEXEC_DIR=usr/lib$LIBDIRSUFFIX/$NAME
	fi
	! [[ $SYSCONF_DIR ]] && SYSCONF_DIR=etc
	! [[ $SHAREDSTATE_DIR ]] && SHAREDSTATE_DIR=var/log
	! [[ $LOCALSTATE_DIR ]] && LOCALSTATE_DIR=var
	! [[ $LIB_DIR ]] && LIB_DIR=usr/lib$LIBDIRSUFFIX
	! [[ $INCLUDE_DIR ]] && INCLUDE_DIR=usr/include
	! [[ $DATA_DIR ]] && DATA_DIR=usr/share
	! [[ $INFO_DIR ]] && INFO_DIR=usr/share/info
	! [[ $LOCALE_DIR ]] && LOCALE_DIR=$DATA_DIR/locale
	! [[ $MAN_DIR ]] && MAN_DIR=usr/share/man
	! [[ $DOC_DIR ]] && DOC_DIR=usr/share/doc
	! [[ $GAMESBIN_DIR ]] && GAMESBIN_DIR=usr/games/bin
	! [[ $GAMESDATA_DIR ]] && GAMESDATA_DIR=usr/share/games
	! [[ $INIT_DIR ]] && INIT_DIR=etc/init.d
	BAD_DOC_PATH=usr/doc
	GOOD_DOC_PATH=usr/share/doc
	BAD_MAN_PATH=usr/man
	GOOD_MAN_PATH=usr/share/man
	BAD_INFO_PATH=usr/info
	GOOD_INFO_PATH=usr/share/info
elif [[ $FHS_POLICY = "NONE" ]] ; then
	! [[ $BIN_DIR ]] && BIN_DIR=$PRE_FIX/bin
	! [[ $SBIN_DIR ]] && SBIN_DIR=$PRE_FIX/sbin
	! [[ $LIBEXEC_DIR ]] && LIBEXEC_DIR=$PRE_FIX/libexec
	! [[ $SYSCONF_DIR ]] && SYSCONF_DIR=$PRE_FIX/etc
	! [[ $SHAREDSTATE_DIR ]] && SHAREDSTATE_DIR=$PRE_FIX/var/log
	! [[ $LOCALSTATE_DIR ]] && LOCALSTATE_DIR=$PRE_FIX/var
	! [[ $LIB_DIR ]] && LIB_DIR=$PRE_FIX/lib$LIBDIRSUFFIX
	! [[ $INCLUDE_DIR ]] && INCLUDE_DIR=$PRE_FIX/include
	! [[ $DATA_DIR ]] && DATA_DIR=$PRE_FIX/share
	! [[ $INFO_DIR ]] && INFO_DIR=$PRE_FIX/info
	! [[ $LOCALE_DIR ]] && LOCALE_DIR=$DATA_DIR/locale
	! [[ $MAN_DIR ]] && MAN_DIR=$PRE_FIX/man
	! [[ $DOC_DIR ]] && DOC_DIR=$PRE_FIX/doc
	! [[ $GAMESBIN_DIR ]] && GAMESBIN_DIR=$PRE_FIX/bin
	! [[ $GAMESDATA_DIR ]] && GAMESDATA_DIR=$PRE_FIX/share
	! [[ $INIT_DIR ]] && INIT_DIR=etc/rc.d
	BAD_DOC_PATH=$PRE_FIX/share/doc
	GOOD_DOC_PATH=$PRE_FIX/doc
	BAD_MAN_PATH=$PRE_FIX/share/man
	GOOD_MAN_PATH=$PRE_FIX/man
	BAD_INFO_PATH=$PRE_FIX/share/info
	GOOD_INFO_PATH=$PRE_FIX/info
	CORRECT_MAKEFILES="NO"
	CORRECT_DOCS="NO"
	CORRECT_MANS="NO"
fi

# add a couple of extra handy dirnames
! [[ $PIXMAPS_DIR ]] && PIXMAPS_DIR=$PRE_FIX/share/pixmaps
! [[ $ICONS_DIR ]] && ICONS_DIR=$PRE_FIX/share/icons

# these lower-case vars are the standard autotools variables
# absolute paths are needed for these. prefix is handled elsewhere
! [[ $bindir ]] && bindir=/$BIN_DIR
! [[ $sbindir ]] && sbindir=/$SBIN_DIR
! [[ $libexecdir ]] && libexecdir=/$LIBEXEC_DIR
! [[ $sysconfdir ]] && sysconfdir=/$SYSCONF_DIR
! [[ $sharedstatedir ]] && sharedstatedir=/$SHAREDSTATE_DIR
! [[ $localstatedir ]] && localstatedir=/$LOCALSTATE_DIR
! [[ $libdir ]] && libdir=/$LIB_DIR
! [[ $includedir ]] && includedir=/$INCLUDE_DIR
! [[ $oldincludedir ]] && oldincludedir=/usr/include
! [[ $datarootdir ]] && datarootdir=/$PRE_FIX
! [[ $datadir ]] && datadir=/$DATA_DIR
! [[ $infodir ]] && infodir=/$INFO_DIR
! [[ $localedir ]] && localedir=$LOCALE_DIR
! [[ $mandir ]] && mandir=/$MAN_DIR
! [[ $docdir ]] && docdir=/$DOC_DIR
! [[ $htmldir ]] && htmldir=/$DOC_DIR/html
! [[ $dvidir ]] && dvidir=/$DOC_DIR
! [[ $pdfdir ]] && pdfdir=/$DOC_DIR
! [[ $psidir ]] && psidir=/$DOC_DIR
! [[ $gamesbindir ]] && gamesbindir=/$GAMESBIN_DIR
! [[ $gamesdatadir ]] && gamesdatadir=/$GAMESDATA_DIR
# add a couple of extras
! [[ $pixmapsdir ]] && pixmapsdir=/$PIXMAPS_DIR
! [[ $iconsdir ]] && iconsdir=/$ICONS_DIR
! [[ $initdir ]] && initdir=$INIT_DIR

! [[ $build ]] && build=$BUILD_OS
! [[ $host ]] && host=$HOST_OS
! [[ $target ]] && target=$TARGET_OS

# now put the PKG_DIR in front of the directory variables. This allows for easy use in scripts
# by simply putting mkdir -p $DOC_DIR ; cp $SRC_DIR/stuff $DOC_DIR
# DOC_DIR is the most used, but the others are included for completeness
BIN_DIR="$PKG_DIR/$BIN_DIR"
SBIN_DIR="$PKG_DIR/$SBIN_DIR"
LIBEXEC_DIR="$PKG_DIR/$LIBEXEC_DIR"
SYSCONF_DIR="$PKG_DIR/$SYSCONF_DIR"
SHAREDSTATE_DIR="$PKG_DIR/$SHAREDSTATE_DIR"
LOCALSTATE_DIR="$PKG_DIR/$LOCALSTATE_DIR"
LIB_DIR="$PKG_DIR/$LIB_DIR"
INCLUDE_DIR="$PKG_DIR/$INCLUDE_DIR"
DATA_DIR="$PKG_DIR/$DATA_DIR"
INFO_DIR="$PKG_DIR/$INFO_DIR"
LOCALE_DIR="$PKG_DIR/$LOCALE_DIR"
MAN_DIR="$PKG_DIR/$MAN_DIR"
DOC_DIR="$PKG_DIR/$DOC_DIR/$NAME-$VERSION"
GAMESBIN_DIR="$PKG_DIR/$GAMESBIN_DIR"
GAMESDATA_DIR="$PKG_DIR/$GAMESDATA_DIR"
# add a couple more handy dirs
PIXMAPS_DIR="$PKG_DIR/$PIXMAPS_DIR"
ICONS_DIR="$PKG_DIR/$ICONS_DIR"
INIT_DIR="$PKG_DIR/$INIT_DIR"
}

check_write_permissions() {
#if [[ "$LOG_DIR" = "$CWD" ]] ; then
	touch "$CWD"/perms-test.txt &> /dev/null
	if [ $? -eq 0 ] ; then
		rm -f "$CWD"/perms-test.txt
	else
		echo $RED"FAILED! "$NORMAL"You don't have permission to create files in"
		echo "the current directory: $CWD"
		FAILED="WRITE_PERMISSION in: $FUNCNAME"
	fi
#else
#	mkdir -p "$LOG_DIR" &> /dev/null
#	touch "$LOG_DIR"/perms-test.txt &> /dev/null
#	if [ $? -eq 0 ] ; then
#		rm -f "$LOG_DIR"/perms-test.txt
#	else
#		echo $RED"FAILED! "$NORMAL"You don't have permission to create files in"
#		echo "the LOG_DIR directory: $LOG_DIR"
#		FAILED="WRITE_PERMISSION in: $FUNCNAME"
#	fi
#	touch "$CWD"/perms-test.txt &> /dev/null
#	if [ $? -eq 0 ] ; then
#		rm -f "$CWD"/perms-test.txt
#	else
#		echo $RED"FAILED! "$NORMAL"You don't have permission to create files in"
#		echo "the current directory: $CWD"
#		FAILED="WRITE_PERMISSION in: $FUNCNAME"
#	fi
#fi

mkdir -p "$SRC_BUILDS_DIR" &> /dev/null
touch "$SRC_BUILDS_DIR"/perms-test.txt &> /dev/null
if [ $? -eq 0 ] ; then
	rm -f "$SRC_BUILDS_DIR"/perms-test.txt
else
	echo $RED"FAILED! "$NORMAL"You don't have permission to create files in"
	echo "the SRC_BUILDS_DIR directory: $SRC_BUILDS_DIR"
	FAILED="WRITE_PERMISSION in: $FUNCNAME"
fi
mkdir -p "$PKG_BUILDS_DIR" &> /dev/null
touch "$PKG_BUILDS_DIR"/perms-test.txt &> /dev/null
if [ $? -eq 0 ] ; then
	rm -f "$PKG_BUILDS_DIR"/perms-test.txt
else
	echo $RED"FAILED! "$NORMAL"You don't have permission to create files in"
	echo "the PKG_BUILDS_DIR directory: $PKG_BUILDS_DIR"
	FAILED="WRITE_PERMISSION in: $FUNCNAME"
fi
mkdir -p "$PKG_DEST_DIR" &> /dev/null
touch "$PKG_DEST_DIR"/perms-test.txt &> /dev/null
if [ $? -eq 0 ] ; then
	rm -f "$PKG_DEST_DIR"/perms-test.txt
else
	echo $RED"FAILED! "$NORMAL"You don't have permission to create files in"
	echo "the PKG_DEST_DIR directory: $PKG_DEST_DIR"
	FAILED="WRITE_PERMISSION in: $FUNCNAME"
fi
}

set_search_dirs() {
## Declare a bunch of system directories. These are barely used in
## the real packaging routines but several checks are done using these
## lists to make sure you haven't given any of these as working directories, etc.
! [[ $BIN_DIRS ]] && \
BIN_DIRS="bin sbin usr/bin usr/sbin usr/X11R6/bin \
usr/X11R7/bin usr/local/bin usr/local/sbin opt/kde/bin"

! [[ $INC_DIRS ]] && \
INC_DIRS="usr/include usr/local/include usr/X11/include \
usr/X11R6/include usr/X11R7/include opt/kde/include \
usr/share/aclocal usr/local/share/aclocal"

! [[ $LIB_DIRS ]] && \
LIB_DIRS="lib$LIBDIRSUFFIX usr/lib$LIBDIRSUFFIX\
usr/local/lib$LIBDIRSUFFIX usr/X11/lib opt/kde/lib"

! [[ $LOCALE_DIRS ]] && \
LOCALE_DIRS="usr/share/locale usr/local/share/locale \
usr/lib/locale usr/X11R6/lib/X11/locale usr/X11R7/lib/X11/locale"

! [[ $MAN_DIRS ]] && \
MAN_DIRS="usr/man usr/local/man usr/share/man usr/local/share/man
usr/info usr/share/info usr/local/share/info usr/X11R6/man usr/X11R7/man"

! [[ $DOC_DIRS ]] && \
DOC_DIRS="usr/doc usr/share/doc usr/local/doc usr/local/share/doc
usr/share/$NAME/doc usr/local/share/$NAME/doc
"

}

# color
get_color_options() {
# Check for color prompting
if [[ $COLOR_PROMPT = "YES" ]] ; then
# ANSI COLORS
CRE="[K"
NORMAL="[0;39m"
# RED: Failure or error message
RED="[1;31m"
# GREEN: Success message
GREEN="[1;32m"
# YELLOW: Warnings
YELLOW="[1;33m"
# BLUE: Summary messages
BLUE="[1;34m"
# MAGENTA: Prompt the user for action
MAGENTA="[1;35m"
# CYAN: Current Process
CYAN="[1;36m"
fi
}

detect_terminal_emulator() {
	if [[ $(which xterm 2> /dev/null) ]] ; then
		TERMINAL_EMULATOR=xterm
	elif [[ $(which x-terminal-emulator 2> /dev/null) ]] ; then
		TERMINAL_EMULATOR=x-terminal-emulator
	elif [[ $(which rxvt 2> /dev/null) ]] ; then
		TERMINAL_EMULATOR=rxvt
	elif [[ $(which konsole 2> /dev/null) ]] ; then
		TERMINAL_EMULATOR=konsole
	elif [[ $(which gnome-terminal 2> /dev/null) ]] ; then
		TERMINAL_EMULATOR=gnome-terminal
	elif [[ $(which mrxvt 2> /dev/null) ]] ; then
		TERMINAL_EMULATOR=mrxvt
	elif [[ $(which aterm 2> /dev/null) ]] ; then
		TERMINAL_EMULATOR=aterm
	elif [[ $(which mlterm 2> /dev/null) ]] ; then
		TERMINAL_EMULATOR=mlterm
	elif [[ $(which eterm 2> /dev/null) ]] ; then
		TERMINAL_EMULATOR=eterm
	else
		TERMINAL_EMULATOR='none'
	fi
}
